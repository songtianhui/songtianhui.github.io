---
title: 吴恩达深度学习笔记
date: 2021-08-04 22:51:29
tags:
categories: ML
mathjax: true
typora-root-url: DL-AN
---



[视频指路](https://www.bilibili.com/video/BV1FT4y1E74V?from=search&seid=7469215768123017337)

<!--more -->

---

# Lesson 1.1

本章是对深度学习神经网络的一个介绍，课程的概览。



# Lesson 1.2

本章主要讲了一下 logisitic 回归，梯度下降，在ML中已经学习了。

然后介绍了 `python` 中的一些知识，向量化、广播、`numpy`、jupyter notebook等，都可以 **rtfm**，不在此赘述。

唯一有一点就是符号上的表示，andrew 喜欢用 $m$ 表示样本个数，$n$ 表示特征数。我习惯 mit 的课教的 $n$ 表示样本数，$d$ 表示特征维数。



# Lesson 1.3

本章算是一个神经网络的引入，介绍一些基本概念，浅层神经网络（shallow neural network）。

![](L1_week3_6.png)

每个神经单元就是这么个计算过程，有输入 $x$，权重 $w$，偏移 $b$，激活函数（activation function） $h$。

- $z = w^T x + b$
- $a = h(z)$

符号： $a_1^{[1](1)} $ ，右上角中括号表示层数，右上角括号中表示第几个样本，右下角表示该层第几个神经元。

对于一个输入样本，避免一层内的 for 循环，向量化计算：
$$
z^{[i]} = W^{[i]} a^{[i-1]} + b^{[i]}\\
a^{[i]} = h(z^{[i]})
$$
$W^{[i]}$ 是第 $i$ 层每个神经元的权重排成的矩阵。

举例图示：
$$
\left[
		\begin{array}{c}
		z^{[1]}_{1}\\
		z^{[1]}_{2}\\
		z^{[1]}_{3}\\
		z^{[1]}_{4}\\
		\end{array}
		\right]
		 =
	\overbrace{
	\left[
		\begin{array}{c}
		...W^{[1]T}_{1}...\\
		...W^{[1]T}_{2}...\\
		...W^{[1]T}_{3}...\\
		...W^{[1]T}_{4}...
		\end{array}
		\right]
		}^{W^{[1]}}
		*
	\overbrace{
	\left[
		\begin{array}{c}
		x_1\\
		x_2\\
		x_3\\
		\end{array}
		\right]
		}^{input}
		+
	\overbrace{
	\left[
		\begin{array}{c}
		b^{[1]}_1\\
		b^{[1]}_2\\
		b^{[1]}_3\\
		b^{[1]}_4\\
		\end{array}
		\right]
		}^{b^{[1]}}
$$


对于所有样本，避免 for 遍历样本，向量化计算：
$$
Z^{[i]} = W^{[i]}A^{[i-1]} + b^{[i]}\\
A^{[i]} = h(Z^{[i]})
$$
其中 $Z^{[i]},A^{[i]}$ 是第 $i$ 层所有样本输出排成的矩阵。

激活函数：**sigmoid**（主要在二分类）, **tanh**（比 sigmoid 常用），**ReLU**（在神经网络中很常用），Leaky ReLU。

前两个有梯度消失的风险。

这里提到一个很重要的问题就是为什么要使用非线性函数而不是直接 $a = z$。因为全用线性激活函数（identity）会使神经网络退化成一个单层模型。

## 反向传播 Back Propagation

也就是神经网络的梯度下降（Gradient Descent）。比较重要，理解一下推倒，本质上是函数求导的链式法则。

代价函数：
$$
J(W, b) = \dfrac{1}{m}\sum\limits_{i= 1}^{m}L(\hat{y}, y)
$$
当参数初始化成某些值后，每次梯度下降都会循环计算以下预测值：$\hat{y}^{(i)},(i=1,2,…,m)$。

有 $dW^{[i]} = \dfrac{\partial J}{\partial W^{[i]}}$, $d b^{[i]} = \dfrac{\partial J}{\partial b^{[i]}}$。

在梯度下降时每一次更新：$W^{[i]}\implies{W^{[i]} - \eta dW^{[i]}},b^{[i]}\implies{b^{[i]} -\eta db^{[i]}}$, $\eta$ 为步长。

反向传播时，就是一个链式求导：
$$
\underbrace{
	\left.
	\begin{array}{l}
	x \\
	w \\
	b 
	\end{array}
	\right\}
	}_{dw=dz \cdot x, db =dz}
	\impliedby \underbrace{z=w^Tx+b}_{dz=da\cdot g^{'}(z),
	g(z)=\sigma(z),
	\frac{dL}{dz}} = \frac{dL}{da} \cdot \frac{da}{dz},
	\frac{d}{ dz} g(z)=g^{'}(z)
	\impliedby \underbrace{a = \sigma(z) 
	\impliedby L(a,y)}_{da=\frac{d}{da}L\left(a,y \right)=(-y\log{\alpha} - (1 - y)\log(1 - a))^{'}=-\frac{y}{a} + \frac{1 - y}{1 - a} }
$$
所以有：

$dz^{[L]} = A^{[L]} - Y$

$dW^{[i]} = \dfrac{1}{m} dZ^{[i]}A^{[i-1]T}$

$db^{[i]} = \dfrac{1}{m}$ `np.sum(dZ^{[i]}, axis=1)​`
$$
dz^{[i]} = \underbrace{W^{[i + 1]T} dz^{[i+1]}}_{(n^{[i]},m)}\quad \times  \underbrace{g^{[i]'}}_{activation \; function \; of \; hidden \; layer}\times  \quad\underbrace{(z^{[i]})}_{(n^{[1]},m)}
$$

- 随机初始化，不要初始化成相同的参数。



# Lesson 1.4

本章介绍深层神经网络，主要就是把前一章讲的只有两层的网络更推广一下，而我们在上一章其实已经推广过了。

## 为什么使用深层表示？

深度神经网络的这许多隐藏层中，较早的前几层能学习一些低层次的简单特征，等到后几层，就能把简单的特征结合起来，去探测更加复杂的东西。

深层的网络隐藏单元数量相对较少，隐藏层数目较多，如果浅层的网络想要达到同样的计算结果则需要指数级增长的单元数量才能达到。

> 说实话，我认为“深度学习”这个名字挺唬人的，这些概念以前都统称为有很多隐藏层的神经网络，但是深度学习听起来多高大上，太深奥了，对么？这个词流传出去以后，这是神经网络的重新包装或是多隐藏层神经网络的重新包装，激发了大众的想象力。	——Andrew



## 搭建神经网络块

其实就是对于每一层，权重矩阵，偏移值，激活函数，在前向传播的时候缓存（cache）好 $z,a$ 等值，用反向传播时计算 $dW,db$ 等。

就放一张老师的板书吧（

![building blocks](network.png)



## 参数和超参数

算法中的**learning rate** $a$（学习率）、**iterations**(梯度下降法循环的数量)、$L$（隐藏层数目）、$n^{[l]}$（隐藏层单元数目）、**choice of activation function**（激活函数的选择）都需要你来设置，这些数字实际上控制了最后的参数$W$和$b$的值，所以它们被称作超参数（Hyperparameter）。

如何寻找超参数：走**Idea—Code—Experiment—Idea**这个循环，尝试各种不同的参数，实现模型并观察是否成功，然后再迭代。

> 应用深度学习领域，一个很大程度基于经验的过程，凭经验的过程通俗来说，就是试直到你找到合适的数值。
>
> 如果你所解决的问题需要很多年时间，只要经常试试不同的超参数，勤于检验结果，看看有没有更好的超参数数值，相信你慢慢会得到设定超参数的直觉，知道你的问题最好用什么数值。



---

# Lesson 2.1

本章主要讲改善神经网络，超参数调试、正则化等内容。

- 当我们有百万量级以上的数据，可以拿 99% 以上的数据来进行训练，几万条用来交叉验证（dev）和测试就可以了。

## 方差/偏差

- 高偏差（**high bias**），欠拟合（**underfitting**）。
- 高方差（**high variance**），过拟合（**overfitting**）。

通过训练集和验证集误差判断：

| Training set error | Dev set error |                      |
| :----------------: | :-----------: | :------------------: |
|         1%         |      15%      |    high variance     |
|        15%         |      16%      |      high bias       |
|        15%         |      30%      | high variance & bias |
|        0.5%        |      1%       | low variance & bias  |



## 基本方法

> 初始模型训练完成后，我首先要知道算法的偏差高不高，如果偏差较高，试着评估训练集或训练数据的性能。如果偏差的确很高，甚至无法拟合训练集，那么你要做的就是选择一个新的网络，比如含有更多隐藏层或者隐藏单元的网络，或者花费更多时间来训练网络，或者尝试更先进的优化算法，后面我们会讲到这部分内容。

- 只要正则适度，通常构建一个更大的网络便可以，在不影响方差的同时减少偏差，而采用更多数据通常可以在不过多影响偏差的同时减少方差。
- 训练网络，选择网络或者准备更多数据，现在我们有工具可以做到在减少偏差或方差的同时，不对另一方产生过多不良影响。



## 正则化（Regularization）

深度学习可能存在过拟合问题——高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，正则化通常有助于避免过拟合或减少你的网络误差。

就是在代价函数里加一个正则化项，一般用 $\dfrac{\lambda}{2m}$乘以$w$范数的平方,其中$\left\| w \right\|_2^2$是$w$的欧几里德范数的平方，$L2$ 正则化。

神经网络中的正则项就是为$\dfrac{\lambda }{2m}\sum\limits_{l = 1}^{L}| W^{[l]}|^{2}$，我们称${||W^{\left[l\right]}||}^{2}$为范数平方，这个矩阵范数${||W^{\left[l\right]}||}^{2}$（即平方范数），被定义为矩阵中所有元素的平方求和。该矩阵范数被称作“弗罗贝尼乌斯范数”，用下标$F$标注。

带正则化的梯度下降中，对$W^{[l]}$的偏导数，把$W^{[l]}$替换为$W^{[l]}$减去学习率乘以$dW$。现在我们要做的就是给$dW$加上这一项$\dfrac {\lambda}{m}W^{[l]}$，然后计算这个更新项，使用新定义的$dW^{[l]}$，它的定义含有相关参数代价函数导数和，以及最后添加的额外正则项。
$$
\begin{aligned}
W^{[l]} :&= W^{[l]}  - \alpha \times \left[(\text{from backpap}) + \dfrac{\lambda}{m}W^{[l]}\right]\\ &= (1 - \frac{\alpha \lambda}{m}) W^{[l]} - \alpha \times (\text{from backpap})
\end{aligned}
$$
*正则化预防过拟合的原因：极限思想，当lambda很大权重为0，退化成欠拟合，有个right fit 的中间态。*



## dropout 正则化

就是随机消掉一些神经元。。。

- **inverted dropout**（反向随机失活）
  - 首先要定义向量$d$，$d^{[3]}$表示网络第三层的**dropout**向量：`d3 = np.random.rand(a3.shape[0],a3.shape[1])` 。
  - 然后看它是否小于某数，我们称之为**keep-prob**，**keep-prob**是一个具体数字，它表示保留某个隐藏单元的概率。
  - 接下来要做的就是从第三层中获取$a^{[3]}$，$a^{[3]}$含有要计算的激活函数，$a^{[3]}$等于上面的$a^{[3]}$乘以 $d^{[3]}$，就是把 $d$ 中 0 对应位置的数归零。（$d$ 实际上是一个布尔数组）
  - 最后，我们向外扩展$a^{[3]}$，用它除以**keep-prob**参数。

显然在测试阶段，我们不使用**dropout**。要同时在 **fpp** 和 **bpp** 中使用 dropout。

*dropout 预防过拟合的原因，dropout 的功能类似于$L2$正则化，与$L2$正则化不同的是应用方式不同会带来一点点小变化，甚至更适用于不同的输入范围。*

- 如果你担心某些层比其它层更容易发生过拟合，可以把某些层的**keep-prob**值设置得比其它层更低，缺点是为了使用交叉验证，你要搜索更多的超级参数，另一种方案是在一些层上应用**dropout**，而有些层不用**dropout**，应用**dropout**的层只含有一个超级参数，就是**keep-prob**。

- 它在其它领域应用得比较少，主要存在于计算机视觉领域，因为我们通常没有足够的数据，所以一直存在过拟合。
- **dropout**一大缺点就是代价函数$J$不再被明确定义，每次迭代，都会随机移除一些节点，如果再三检查梯度下降的性能，实际上是很难进行复查的。



## 其他正则化方法

- 数据扩增
- **early stopping**
  - 缺点是不能独立处理梯度下降和优化代价函数。



## 归一化输入（Normalizing）

训练神经网络，其中一个加速训练的方法就是归一化输入。归一化需要两个步骤：

1. 零均值
   - $\mu = \frac{1}{m}\sum\limits_{i =1}^{m}x^{(i)}$，它是一个向量，$x$ 等于每个训练数据 $x$ 减去 $\mu$，意思是移动训练集，直到它完成零均值化。 
2. 归一化方差
   - $ \sigma^{2}= \frac{1}{m}\sum\limits_{i =1}^{m}(x^{(i)})^{2} $，$\sigma^{2}$是一个向量，它的每个特征都有方差，把所有数据除以向量$\sigma^{2}$。



## 梯度消失/梯度爆炸（Vanishing / Exploding gradients）

神经网络层数多了，激活函数就会以指数级递增或递减。



## 神经网络权重的初始化

针对梯度消失/爆炸，有一个方案就是更谨慎地选择随机初始化参数。

$z = w_{1}x_{1} + w_{2}x_{2} + \ldots +w_{n}x_{n}$，为了预防$z$值过大或过小，希望每项值更小，最合理的方法就是设置$w_{i}=\frac{1}{n}$，$n$表示神经元的输入特征数量。

实际上，你要做的就是设置某层权重矩阵 `W[l] = np.random.randn(shape) * np.sqrt(1 / n[l-1])`，$n^{[l - 1]}$ 就是我喂给第$l$层神经单元的数量（即第$l-1$层神经元数量）。

如果你是用的是**Relu**激活函数，而不是$\frac{1}{n}$，方差设置为$\frac{2}{n}$，效果会更好。

对于**tanh**函数来说，用$\sqrt{\frac{1}{n^{[l-1]}}}$。



## 梯度的数值逼近 Numerical approximation of gradients

就是导数定义，双边误差，即$\frac{f\left(\theta + \varepsilon \right) - f(\theta -\varepsilon)}{2\varepsilon}$。

先将所有的参数 $W, b$ 展开成一个大向量 $\theta$，在**bpp**中，算完梯度之后所有的梯度 $dW, db$ 就是 $d\theta$。

然后比较 $d\theta_{\text{approx}}\left[i \right] = \frac{J\left( \theta_{1},\theta_{2},\ldots\theta_{i} + \varepsilon,\ldots \right) - J\left( \theta_{1},\theta_{2},\ldots\theta_{i} - \varepsilon,\ldots \right)}{2\varepsilon}$ 和 $d\theta[i]$ 的值接不接近。

就计算它们的欧式距离再归一化，$\dfrac{||d\theta_{\text{approx}} -d\theta||_{2}}{||d\theta_{\text{approx}}||_2 + ||d\theta||_2}$。计算得到的值为$10^{-7}$或更小，这就很好；如果它的值在$10^{-5}$范围内，就要小心了，也许这个值没问题，但再次检查这个向量的所有项，确保没有一项误差过大，可能这里有**bug**。如果比$10^{-3}$大很多，就会很担心是否存在**bug**，这时应该仔细检查所有$\theta$项，看是否有一个具体的$i$值，使得$d\theta_{\text{approx}}\left[i \right]$与$ d\theta[i]$大不相同，并用它来追踪一些求导计算是否正确。



## 梯度检验的注意事项

1. 不要在训练中使用梯度检验，它只用于调试。
2. 如果算法的梯度检验失败，要检查所有项，检查每一项，并试着找出**bug**。
3. 在实施梯度检验时，如果使用正则化，请注意正则项。
4. 梯度检验不能与**dropout**同时使用，因为每次迭代过程中，**dropout**会随机消除隐藏层单元的不同子集，难以计算**dropout**在梯度下降上的代价函数$J$。



# Lesson 2.2

本节课主要讲优化算法，也就是我们如何更新参数。

## Mini-batch 梯度下降

你可以把训练集分割为小一点的子集训练，这些子集被取名为**mini-batch**，每个子集记作 $X^{\{i\}}$。就是把原来梯度下降时代入整个训练集改成代入一个mini-batch，然后多梯度下降几次。

使用**mini-batch**梯度下降法，如果作出成本函数在整个过程中的图，则并不是每次迭代都是下降的，特别是在每次迭代中，你要处理的是$X^{\{t\}}$和$Y^{\{ t\}}$。如果要作出成本函数$J$的图，你很可能会看到这样的结果，走向朝下，但有更多的噪声。

需要决定的变量之一是**mini-batch**的大小。首先，如果训练集较小，直接使用**batch**梯度下降法。样本数目较大的话，一般的**mini-batch**大小为64到512，考虑到电脑内存设置和使用的方式，如果**mini-batch**大小是2的$n$次方，代码会运行地快一些。



## 指数加权平均数 Exponentially weighted averages

递推式：
$$
v_t = \beta v_{t - 1} + (1 - \beta)\theta_t
$$
如果我们将其展开，这就是一个加权平均，是从 $0$ 到 $t$ 每个 $\theta_i$ 的平均，越远权重越小。

考虑 $\beta^{x} = \frac{1}{e}$，这个算的大约就是 $x$ 天的平均数。

指数加权平均数公式的好处之一在于，它占用极少内存，电脑内存中只占用一行数字而已，然后把最新数据代入公式，不断覆盖就可以了。

不过有可能会遇到 **偏差修正（bias corrections）的问题**

因为我们取 $v_0 = 0$，所以会使得 $i$ 较小时 $v_i$ 所占权重都很小，估算不准确。

我们可以在估测初期，不用 $v_t$，而是 $\dfrac{v_t}{1 - \beta^t}$。

不过在机器学习中，在计算指数加权平均数的大部分时候，大家不在乎执行偏差修正。



## 动量梯度下降法 Gradient descent with Momentum

有一种算法叫做**Momentum**，或者叫做动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法，基本的想法就是计算梯度的指数加权平均数，并利用该梯度更新你的权重。

计算动量：
$$
v_{dW} = \beta v_{dW} + (1 - \beta) dW
$$

$$
v_{db} = \beta v_{db} + (1 - \beta) db
$$

再更新参数：
$$
W := W - \alpha v_{dW}
$$

$$
b := b - \alpha v_{db}
$$

这样就可以减缓梯度下降的幅度。*它们能够最小化碗状函数，这些微分项，想象它们为从山上往下滚的一个球，提供了加速度，**Momentum**项相当于速度。*

所以有两个超参数，学习率 $a$ 以及参数 $\beta$，$\beta$ 控制着指数加权平均数。$\beta$ 最常用的值是0.9，是很棒的鲁棒数。

有一个版本是 $v_{dW} = \beta v_{dW} + dW$，本质上没有区别。



## RMSprop

**root mean square prop**算法，它也可以加速梯度下降，通过加快损失下降的方向，减缓无关方向，减少摆动。
$$
S_{dW}= \beta S_{dW} + (1 -\beta) (dW)^{2}
$$

$$
S_{db}= \beta S_{db} + (1 - \beta)(db)^{2}
$$

再更新参数：
$$
W:= W -\alpha \dfrac{dW}{\sqrt{S_{dW}}}
$$

$$
b:=b -\alpha \dfrac{db}{\sqrt{S_{db}}}
$$

为了确保数值稳定，在实际操练的时候，要在分母上加上一个很小很小的$\varepsilon$，$\varepsilon$是多少没关系，$10^{-8}$是个不错的选择.



## Adam

把前面两个缝起来。

首先初始化：$v_{dW} = 0$，$S_{dW} =0$，$v_{db} = 0$，$S_{db} =0$。
$$
v_{dW}= \beta_{1}v_{dW} + ( 1 - \beta_{1})dW
$$

$$
v_{db}= \beta_{1}v_{db} + ( 1 -\beta_{1} )db
$$

$$
S_{dW}=\beta_{2}S_{dW} + ( 1 - \beta_{2})(dW)^{2}
$$

$$
S_{db} =\beta_{2}S_{db} + ( 1 - \beta_{2} )(db)^{2}
$$
一般使用**Adam**算法的时候，要计算偏差修正，$v_{dW}^{\text{corrected}}$，修正也就是在偏差修正之后：
$$
v_{dW}^{\text{corrected}}= \dfrac{v_{dW}}{1 - \beta_{1}^{t}}
$$

$$
v_{db}^{\text{corrected}} =\dfrac{v_{db}}{1 -\beta_{1}^{t}}
$$

$$
S_{dW}^{\text{corrected}} =\dfrac{S_{dW}}{1 - \beta_{2}^{t}}
$$

$$
S_{db}^{\text{corrected}} =\dfrac{S_{db}}{1 - \beta_{2}^{t}}
$$
最后更新权重：
$$
W:= W - \dfrac{\alpha v_{dW}^{\text{corrected}}}{\sqrt{S_{dW}^{\text{corrected}}} +\varepsilon}
$$

$$
b:=b - \frac{\alpha v_{\text{db}}^{\text{corrected}}}{\sqrt{S_{\text{db}}^{\text{corrected}}} +\varepsilon}
$$
**Adam** 是一种极其常用的学习算法，被证明能有效适用于不同神经网络，适用于广泛的结构。

本算法中有很多超参数，超参数学习率$a$很重要，也经常需要调试，你可以尝试一系列值，然后看哪个有效。$\beta_{1}$常用的缺省值为0.9。超参数$\beta_{2}$，**Adam**论文作者，也就是**Adam**算法的发明者，推荐使用0.999。关于$\varepsilon$的选择其实没那么重要，**Adam**论文的作者建议$\varepsilon$为$10^{-8}$。



## 学习率衰减 Learning rate decay

慢慢减少$a$的本质在于，在学习初期，你能承受较大的步伐，但当开始收敛的时候，小一些的学习率能让你步伐小一些。

$a= \dfrac{1}{1 + decayrate \times \text{epoch}\text{-num}}a_{0}$，（**decay-rate**称为衰减率，**epoch-num**为代数，$\alpha_{0}$为初始学习率），注意这个衰减率是另一个需要调整的超参数。

人们用到的其它公式有$a =\dfrac{k}{\sqrt{\text{epoch-num}}}a_{0}$或者$a =\dfrac{k}{\sqrt{t}}a_{0}$（$t$为**mini-batch**的数字）。



## 局部最优问题 Local optima

在深度学习研究早期，人们总是担心优化算法会困在极差的局部最优，不过随着深度学习理论不断发展，我们对局部最优的理解也发生了改变。

事实上，如果你要创建一个神经网络，通常梯度为零的点并不是这个图中的局部最优点，实际上成本函数的零梯度点，通常是鞍点。

意思就是一个最优点需要所有维度都是极小，在现在高维特征下很难遇到，所以碰到的所谓局部最优一般都不是最优，都可以跑出来。



# Lesson 2.3

本章主要讲了超参数调试，归一化和深度学习框架。

## 调试处理 Tuning process

画格子取点。

超参数范围，对数尺。

**Pandas**，小模型，每天逐渐变化超参数。

**Caviar**，大模型，多个参数同时跑几天。



## 归一化激活函数 Normalizing activation

就是 **Batch 归一化**，会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定。

实践中，经常做的是归一化$z^{[i]}$。
$$
\mu = \dfrac{1}{m} \sum\limits_i z^{(i)}
$$

$$
\sigma^2 = \dfrac{1}{m} \sum\limits_i (z_i - \mu)^2
$$

$$
z_{norm}^{(i)} = \dfrac{z^{(i)} - \mu}{\sqrt{\sigma^2 + \varepsilon}}
$$

所以现在我们已把这些$z$值标准化，化为含平均值0和标准单位方差，所以$z$的每一个分量都含有平均值0和方差1，但我们不想让隐藏单元总是含有平均值0和方差1，也许隐藏单元有了不同的分布会有意义，所以我们所要做的就是计算 $\tilde{z}^{(i)} = \gamma z_{norm}^{(i)} + \beta$，这里$\gamma$和$\beta$是你模型的学习参数，作用是可以随意设置${\tilde{z}}^{(i)}$的平均值。

*应用Batch归一化了一些隐藏单元值中的平均值和方差，不过训练输入和这些隐藏单元值的一个区别是，你也许不想隐藏单元值必须是平均值0和方差1。它真正的作用是，使隐藏单元值的均值和方差标准化，即$z^{(i)}$有固定的均值和方差，均值和方差可以是0和1，也可以是其它值，它是由$\gamma$和$\beta$两参数控制的。*



至于如何将 *BN* 层放进神经网络——tensorflow(



## Batch Norm 为什么有用

通过归一化所有的输入特征值$x$，以获得类似范围的值，可以加速学习，不仅仅对于这里的输入值，还有隐藏单元的值。

**Batch**归一化有效的第二个原因是，它可以使权重比你的网络更滞后或更深层。对于网络的泛化能力，浅层网络不一定能做的很好，所以我们尝试改变数据的分布，有个有点怪的名字“**Covariate shift**”。如果你已经学习了$x$到$y$ 的映射，如果$x$ 的分布改变了，那么你可能需要重新训练你的学习算法。这种做法同样适用于，如果真实函数由$x$ 到$y$ 映射保持不变。

按我的理解，就是前一层对于后一层的影响。当前一层的分布变化之后，后一层就要面临 **Covariate shift** 的问题，就会不稳定。而 Batch 归一化做的就是它减少了这些隐藏值分布变化的数量，使分布更稳定，神经网络的之后层就会有更坚实的基础。它限制了在前层的参数更新，会影响数值分布的程度，在后一层看到的这种情况，因此得到学习。

*即使使输入分布改变了一些，它会改变得更少。它做的是当前层保持学习，当改变时，迫使后层适应的程度减小了，你可以这样想，它减弱了前层参数的作用与后层参数的作用之间的联系，它使得网络每层都可以自己学习，稍稍独立于其它层，这有助于加速整个网络的学习。*



还有轻微的正则化的作用。因为均值和方差有一点小噪音，因为它只是由一小部分数据估计得出的。



## Softmax 回归

有一种**logistic**回归的一般形式，叫做**Softmax**回归，能让你在试图识别某一分类时做出预测，或者说是多种分类中的一个，不只是识别两个分类。
$$
t=e^{z^{[l]}}
$$

$$
a_{i}^{[l]} = \dfrac{t_{i}}{\sum\limits_i t_{i}}
$$

输出的 $a_i$ 就是第 $i$ 类的概率。

训练 softmax 分类器用的损失	函数一般是 $L(\hat{y},y ) = - \sum\limits_{j}y_{j}\log{\hat{y}_{j}}$。



## 深度学习框架

- Caffe/Caffe2
- NCTK
- DL4J
- Keras
- Lasagne
- mxnet
- PaddlePaddle
- TensorFlow
- Theano
- Torch



# Lesson 3.1

本章主要介绍机器学习策略。很多事思想意识上的东西，可能很多照搬原话（

## 正交化 Orthogonalization

意思大概就是把所有特征正交到几个相互独立的特征上。

> 在机器学习中，如果你可以观察你的系统，然后说这一部分是错的，它在训练集上做的不好、在开发集上做的不好、它在测试集上做的不好，或者它在测试集上做的不错，但在现实世界中不好，这就很好。必须弄清楚到底是什么地方出问题了，然后我们刚好有对应的旋钮，或者一组对应的旋钮，刚好可以解决那个问题，那个限制了机器学习系统性能的问题。



## 单一数字评估指标 Single number evaluation metric

无论是调整超参数，或者是尝试不同的学习算法，或者在搭建机器学习系统时尝试不同手段，如果你有一个单实数评估指标，进展会快得多，它可以快速告诉你，新尝试的手段比之前的手段好还是差。所以当团队开始进行机器学习项目时，推荐为问题设置一个单实数评估指标（F1 分数，平均值）。

有一个开发集，加上单实数评估指标，迭代速度肯定会很快，它可以加速改进机器学习算法的迭代过程。



## 满足和优化指标 Satisficing and optimizing metrics

要把顾及到的所有事情组合成单实数评估指标有时并不容易，在那些情况里，有时候设立满足和优化指标是很重要的。

优化指标，想要准确度最大化，想做的尽可能准确。

满足指标，意思是它必须足够好，达到标准之后，不那么在乎这指标有多好。

通过定义优化和满足指标，就可以提供一个明确的方式，去选择“最好的”分类器。



## 训练/开发/测试集划分 train/dev/test distributions

开发（**dev**）集也叫做开发集（**development set**），有时称为保留交叉验证集（**hold out cross validation set**）。然后，机器学习中的工作流程是，尝试很多思路，用训练集训练不同的模型，然后使用开发集来评估不同的思路，然后选择一个，然后不断迭代去改善开发集的性能，直到最后可以得到一个令你满意的成本，然后你再用测试集去评估。

让开发集和测试集来自同一分布，通过将所有数据随机洗牌。

大小 98:1:1.

*处理机器学习问题时，应该把它切分成独立的步骤。一步是弄清楚如何定义一个指标来衡量你想做的事情的表现，然后我们可以分开考虑如何改善系统在这个指标上的表现。要把机器学习任务看成两个独立的步骤，用目标这个比喻，第一步就是设定目标。所以要定义你要瞄准的目标，这是完全独立的一步，这是你可以调节的一个旋钮。如何设立目标是一个完全独立的问题，把它看成是一个单独的旋钮，可以调试算法表现的旋钮，如何精确瞄准，如何命中目标，定义指标是第一步。*

*然后第二步要做别的事情，在逼近目标的时候，也许学习算法针对某个成本函数优化，要最小化训练集上的损失。可以做的其中一件事是，修改这个，为了引入权重，也许最后需要修改这个归一化常数。*

如何定义$J$并不重要，关键在于正交化的思路。将定义指标看成一步，然后在定义了指标之后，你才能想如何优化系统来提高这个指标评分。比如改变你神经网络要优化的成本函数$J$。

>所以我的建议是，即使你无法定义出一个很完美的评估指标和开发集，你直接快速设立出来，然后使用它们来驱动你们团队的迭代速度。如果在这之后，你发现选的不好，你有更好的想法，那么完全可以马上改。对于大多数团队，我建议最好不要在没有评估指标和开发集时跑太久，因为那样可能会减慢你的团队迭代和改善算法的速度。



## 为什么是人的表现 Why human-level performance?

在过去的几年里，更多的机器学习团队一直在讨论如何比较机器学习系统和人类的表现。

> 我认为有两个主要原因，首先是因为深度学习系统的进步，机器学习算法突然变得更好了。在许多机器学习的应用领域已经开始见到算法已经可以威胁到人类的表现了。其次，事实证明，当你试图让机器做人类能做的事情时，可以精心设计机器学习系统的工作流程，让工作流程效率更高，所以在这些场合，比较人类和机器是很自然的，或者你要让机器模仿人类的行为。

当这个算法表现比人类更好时，进展和精确度的提升就变得更慢了。也许它还会越来越好，但是在超越人类水平之后，它还可以变得更好，但性能增速，准确度上升的速度这个斜率，会变得越来越平缓，我们都希望能达到理论最佳性能水平。随着时间的推移，当继续训练算法时，可能模型越来越大，数据越来越多，但是性能无法超过某个理论上限，这就是所谓的贝叶斯最优错误率（**Bayes optimal error**）。

所以贝叶斯最优错误率一般认为是理论上可能达到的最优错误率，就是说没有任何办法设计出一个$x$到$y$的函数，让它能够超过一定的准确度。



## 可避免偏差 Avoidable bias

在之前的课程关于偏差和方差的讨论中，我们主要假设有一些任务的贝叶斯错误率几乎为0。根据定义，人类水平错误率比贝叶斯错误率高一点，因为贝叶斯错误率是理论上限，但人类水平错误率离贝叶斯错误率不会太远。

对贝叶斯错误率的估计和训练错误率之间的差值称为可避免偏差。这个训练错误率和开发错误率之前的差值，就大概说明你的算法在方差问题上还有多少改善空间。



*理解偏差和方差，那么在人类可以做得很好的任务中，你可以估计人类水平的错误率，你可以使用人类水平错误率来估计贝叶斯错误率。所以你到贝叶斯错误率估计值的差距，告诉你可避免偏差问题有多大，可避免偏差问题有多严重，而训练错误率和开发错误率之间的差值告诉你方差上的问题有多大，你的算法是否能够从训练集泛化推广到开发集。*

要达到超越人类的表现往往不容易，但如果有足够多的数据，已经有很多深度学习系统，在单一监督学习问题上已经超越了人类的水平，所以这对在开发的应用是有意义的。



# Lesson 3.2

本章还是机器学习策略。

## 误差分析 Error analysis

进行错误分析，应该找一组错误样本，可能在你的开发集里或者测试集里，观察错误标记的样本，看看假阳性（**false positives**）和假阴性（**false negatives**），统计属于不同错误类型的错误数量。在这个过程中，可能会得到启发，归纳出新的错误类型。

通过统计不同错误标记类型占总数的百分比，可以帮你发现哪些问题需要优先解决，或者给你构思新优化方向的灵感。



## 清楚标记错误的数据 Cleaning up incorrectly labeled data

首先，考虑训练集，事实证明，深度学习算法对于训练集中的随机错误是相当健壮的（**robust**）。标记出错的样本，只要这些错误样本离随机错误不太远，有时可能做标记的人没有注意或者不小心，按错键了，如果错误足够随机，那么放着这些错误不管可能也没问题，而不要花太多时间修复它们。

如果这些标记错误严重影响了在开发集上评估算法的能力，那么就应该去花时间修正错误的标签。但是，如果它们没有严重影响到用开发集评估成本偏差的能力，那么可能就不应该花宝贵的时间去处理。

- 对开发集和测试集做同样的处理来确保他们保持同样的分布。
- 同时检验算法判断正确和错误的样本。
- 训练集和开发/测试集可能来自不同分布。

> 首先，深度学习研究人员有时会喜欢这样说：“我只是把数据提供给算法，我训练过了，效果拔群”。这话说出了很多深度学习错误的真相，更多时候，我们把数据喂给算法，然后训练它，并减少人工干预，减少使用人类的见解。但我认为，在构造实际系统时，通常需要更多的人工错误分析，更多的人类见解来架构这些系统，尽管深度学习的研究人员不愿意承认这点。
>
> 其次，不知道为什么，我看一些工程师和研究人员不愿意亲自去看这些样本，也许做这些事情很无聊，坐下来看100或几百个样本来统计错误数量，但我经常亲自这么做。当我带领一个机器学习团队时，我想知道它所犯的错误，我会亲自去看看这些数据，尝试和一部分错误作斗争。我想就因为花了这几分钟，或者几个小时去亲自统计数据，真的可以帮你找到需要优先处理的任务，我发现花时间亲自检查数据非常值得，所以我强烈建议你们这样做，如果你在搭建你的机器学习系统的话，然后你想确定应该优先尝试哪些想法，或者哪些方向。

~~大佬之所以是大佬~~。



## 迁移学习 Transfer learning

深度学习中，最强大的理念之一就是，有的时候神经网络可以从一个任务中习得知识，并将这些知识应用到另一个独立的任务中。所以例如，也许你已经训练好一个神经网络，能够识别像猫这样的对象，然后使用那些知识，或者部分习得的知识去帮助您更好地阅读x射线扫描图，这就是所谓的迁移学习。

具体来说，在第一阶段训练过程中，当进行图像识别任务训练时，可以训练神经网络的所有常用参数，所有的权重，所有的层，然后就得到了一个能够做图像识别预测的网络。在训练了这个神经网络后，要实现迁移学习，现在要做的是，把数据集换成新的$(x,y)$对，现在这些变成放射科图像，而$y$是想要预测的诊断，要做的是初始化最后一层的权重，在这个新数据集上重新训练网络。

经验规则是，如果有一个小数据集，就只训练输出层前的最后一层，或者也许是最后一两层。但是如果有很多数据，那么也许可以重新训练网络中的所有参数。如果重新训练神经网络中的所有参数，那么这个在图像识别数据的初期训练阶段，有时称为预训练（**pre-training**），因为在用图像识别数据去预先初始化，或者预训练神经网络的权重。然后，如果以后更新所有权重，有时这个过程叫微调（**fine tuning**）。

迁移学习起作用的场合是，在迁移来源问题中你有很多数据，但迁移目标问题你没有那么多数据。

- 任务 A 和 B 有相同的输入 $x$。
- A 有比 B 更多的数据。
- A 的低级特征对于 B 的学习有帮助。



## 多任务学习 Multi-task learning

在迁移学习中，你的步骤是串行的，你从任务$A$里学习只是然后迁移到任务$B$。在多任务学习中，你是同时开始学习的，试图让单个神经网络同时做几件事情，然后希望这里每个任务都能帮到其他所有任务。

输出 $y^{(i)}$ 不再是一个标签，而是几个标签，表示不同的任务输出，网络的最后一层变成矩阵 $Y$。损失函数就是所有的输出损失求和。

多任务学习什么时候有意义：

- 训练的一组任务可以共用低层次特征。

- 每个任务的数据量很接近。
- 可以训练一个足够大的神经网络，同时做好所有的工作。



## 端到端的深度学习 End-to-end deep learning

终于知道所说的端到端是啥意思了。。。

简而言之，以前有一些数据处理系统或者学习系统，它们需要多个阶段的处理。那么端到端深度学习就是忽略所有这些不同的阶段，用单个神经网络代替它。

它表现可以很好，也可以简化系统架构，不需要搭建那么多手工设计的单独组件，但它也不是灵丹妙药，并不是每次都能成功。

优点：

- 只通过数据，而不引入更多的人为概念。（Let the data speak）

- 更少的手工设计的组件。

缺点：

- 需要大量的数据。
- 排除了可能有用的手工设计的组件。





# Lesson 5.1

本节主要讲序列模型（Sequence Models）。



## 数学符号 Notation

$x^{<t>}$：序列的中间位置，$t$ 索引。

$T_x$：输入序列的长度。

$T_y$：输出序列的长度。

**one-hot** 法表示字典中的每一个单词。

**Unknow Word** 伪造单词，<**UNK**>。



## 循环神经网络 Recurrent Neural Network

简单来说，在时间步 $t$ 中，模型不仅是用 $x^{<t>}$ 来预测 $\hat{y}^{<t>}$，而且还用了前一个时间步中的信息，也就是时间步 $t-1$ 的激活值会传递到 $t$。

有一个零时刻的初始激活值 $a^{<0>} = \mathbf{0}$。

循环神经网络是从左向右扫描数据，同时每个时间步的参数也是共享的。$W_{\text{ax}}$ 表示管理着从 $x^{<1>}$ 到隐藏层的连接的一系列参数，每个时间步使用的都是相同的参数 $W_{\text{ax}}$。而激活值也就是水平联系是由参数 $W_{aa}$ 决定的，同时每一个时间步都使用相同的参数 $W_{aa}$，同样的输出结果由 $W_{\text{ya}}$ 决定。

![](rnn.png)

这个循环神经网络的一个缺点就是它只使用了这个序列中之前的信息来做出预测。

计算示例（FPP）：

$a^{< t >} = g_{1}(W_{aa}a^{< t - 1 >} + W_{ax}x^{< t >} + b_{a})$

$\hat y^{< t >} = g_{2}(W_{{ya}}a^{< t >} + b_{y})$

循环神经网络用的激活函数经常是**tanh**。

简化符号：

$a^{<t>} =g(W_{a}\left\lbrack a^{< t-1 >},x^{<t>} \right\rbrack +b_{a})$

$\hat y^{< t >} = g(W_{y}a^{< t >} +b_{y})$

所以我们定义$W_{a}$的方式是将矩阵$W_{aa}$和矩阵$W_{ax}$水平并列放置，$[ W_{aa}\vdots W_{ax}]=W_{a}$。

用这个符号（$\left\lbrack a^{< t - 1 >},x^{< t >}\right\rbrack$）的意思是将这两个向量堆在一起，用这个符号表示，即$\begin{bmatrix}a^{< t-1 >} \\ x^{< t >} \\\end{bmatrix}$。

![](rnn-f.png)



## 通过时间的反向传播 Backpropagation through time

![](rnn_cell_backprop.png)

## 不同类型的循环神经网络

- 多对多
- 多对一
- 一对一
- 一对多



## 语言模型和序列生成 Sequence generation

所以语言模型所做的就是，预测某个特定的句子它出现的概率是多少。

为了使用**RNN**建立出这样的模型，首先需要一个训练集，包含一个很大的英文文本语料库（**corpus**）或者其它的语言，用于构建模型的语言的语料库。语料库是自然语言处理的一个专有名词，就是很长的或者说数量众多的英文句子组成的文本。

就是根据前面所给的单词，在下一个时间步预测出下一个单词的分布。



## 新序列采样 Sampling novel sequences

就是把每一个时间步的输出传递到下一个时间步，直到 **EOS**。



## 循环神经网络的梯度消失 Vanishing gradients with RNNs

一个很深很深的网络，对这个网络从左到右做前向传播然后再反向传播。如果这是个很深的神经网络，从输出$\hat y$得到的梯度很难传播回去，很难影响靠前层的权重，很难影响前面层的计算。

**RNN** 一个时间步的输出，基本上很难受到序列靠前的输入的影响，这是因为不管输出是什么，不管是对的，还是错的，这个区域都很难反向传播到序列的前面部分，也因此网络很难调整序列前面的计算。



## 门控循环单元 Gated Recurrent Unit

**GRU** 能够改变 **RNN** 的隐藏层，使其可以更好地捕捉深层连接，并改善了梯度消失问题。

有个新的变量称为$c$，代表细胞（**cell**），即记忆细胞，记忆细胞的作用是提供了记忆的能力。实际上用的就是激活值 $c^{<t>} = a^{<t>}$。

在每个时间步，将用一个候选值重写记忆细胞，用 **tanh** 来激活。
$$
\tilde{c}^{<t>} = \tanh{\left( W_c [c^{<t-1>}, x^{<t>}] + b_c \right)}
$$
在**GRU**中真正重要的思想是有一个门，叫做$\Gamma_{u}$，这是个下标为 $u$ 的大写希腊字母 $\Gamma$，$u$ 代表更新（update），这是一个0到1之间的值。
$$
\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})
$$
然后门决定是否要真的更新它。
$$
c^{<t>} = \Gamma_{u} \times \tilde{c}^{<t>} +\left( 1- \Gamma_{u} \right)*c^{<t-1>}
$$
因为$\Gamma_{u}$很接近0，可能是0.000001或者更小，这就不会有梯度消失的问题了。因为$\Gamma_{u}$很接近0，这就是说$c^{<t>}$几乎就等于$c^{<t-1>}$，而且$c^{<t>}$的值也很好地被维持了，即使经过很多很多的时间步。

对于完整的 **GRU**，还有一个门 $\Gamma_r$，$r$ 表示相关性（relevance），这个 $\Gamma_{r}$ 门告诉你计算出的下一个$c^{<t>}$的候选值${\tilde{c}}^{<t>}$跟$c^{<t-1>}$有多大的相关性。
$$
\Gamma_{r}= \sigma(W_{r}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack + b_{r})
$$

> 这是多年来研究者们试验过很多很多不同可能的方法来设计这些单元，去尝试让神经网络有更深层的连接，去尝试产生更大范围的影响，还有解决梯度消失的问题，**GRU**就是其中一个研究者们最常使用的版本，也被发现在很多不同的问题上也是非常健壮和实用的。你可以尝试发明新版本的单元，只要你愿意。但是**GRU**是一个标准版本，也就是最常使用的。



## 长短期记忆 Long short term memory

$$
\tilde{c}^{<t>} = \tanh{(W_c\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack) + b_c}
$$

$$
\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})
$$

$$
\Gamma_{f}= \sigma(W_{f}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{f})
$$

$$
\Gamma_{o}= \sigma(W_{o}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{o})
$$

$$
c^{<t>} = \Gamma_u \times \tilde{c}^{<t>} + \Gamma_f \times c^{<t-1>}
$$

$$
a^{<t>} = \Gamma_o \times c^{<t>}
$$

常用的版本可能是门值不仅取决于$a^{<t-1>}$和$x^{<t>}$，有时候也可以偷窥一下$c^{<t-1>}$的值（上图编号13所示），这叫做“窥视孔连接”（**peephole connection**）。

只要正确地设置了遗忘门和更新门，**LSTM**是相当容易把$c^{<0>}$的值一直往下传递到右边。这就是为什么**LSTM**和**GRU**非常擅长于长时间记忆某个值，对于存在记忆细胞中的某个值，即使经过很长很长的时间步。

![](LSTM.png)

**GRU**的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。

但是**LSTM**更加强大和灵活，因为它有三个门而不是两个。**LSTM**在历史进程上是个更优先的选择。



## 双向循环神经网络 Bidirectional RNN

就是正着跑一遍再反着跑一遍，是一个无环图（Acyclic graph）。

![](brnn.png)

会有 $\hat y^{<t>} =g(W_{g}\left\lbrack \overrightarrow{a}^{< t >},\overleftarrow{a}^{< t >} \right\rbrack +b_{y})$。

通过这些改变，就可以用一个用**RNN**或**GRU**或**LSTM**构建的模型，并且能够预测任意位置，即使在句子的中间，因为模型能够考虑整个句子的信息。这个双向**RNN**网络模型的缺点就是需要完整的数据的序列，才能预测任意位置。



## 深层循环神经网络 Deep RNNs

要学习非常复杂的函数，通常我们会把**RNN**的多个层堆叠在一起构建更深的模型。

可以堆好几个隐藏层 $a^{[i]}$。

可以输出后再叠非循环层。

![](drnn.png)

由于深层的**RNN**训练需要很多计算资源，需要很长的时间，尽管看起来没有多少循环层，这个也就是在时间上连接了三个深层的循环层，看不到多少深层的循环层，不像卷积神经网络一样有大量的隐含层。
